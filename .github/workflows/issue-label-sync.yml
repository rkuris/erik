name: Sync issue labels from Project fields

on:
  issues:
    types: [opened, edited, reopened, labeled, unlabeled, assigned, unassigned]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to target when running manually'
        required: false
      fail_on_noop:
        description: 'If true, fail the job when no label changes were applied'
        required: false

permissions:
  issues: write
  contents: read

jobs:
  sync-labels:
    name: Sync labels from Project fields
    runs-on: ubuntu-latest
    steps:
      - name: Sync labels from Project fields
        uses: actions/github-script@v6
        env:
          # Set to 'true' to make the job fail when no label updates are applied (useful for strict CI)
          FAIL_ON_NOOP: 'false'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let issue = context.payload.issue;
            // Make owner/repo available before any code path that may call the REST API
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            if (!issue) {
              const inputs = (context.payload && context.payload.inputs) || {};
              const issueNumberInput = inputs.issue_number || inputs.issueNumber || process.env.INPUT_ISSUE_NUMBER;
              if (!issueNumberInput) {
                core.info('No issue payload or dispatch input â€” skipping.');
                return;
              }
              const fetched = await github.rest.issues.get({ owner, repo, issue_number: Number(issueNumberInput) });
              issue = fetched.data;
            }

            const issueNodeId = issue.node_id;
            const issueNumber = issue.number;

            // Query ProjectV2 items attached to this issue and read single-select/text values
            const query = `query($issueId: ID!) {
              node(id: $issueId) {
                ... on Issue {
                  projectItems(first: 20) {
                    nodes {
                      id
                      project { id title }
                      fieldValues(first: 50) {
                        nodes {
                          ... on ProjectV2ItemFieldSingleSelectValue {
                            field {
                              ... on ProjectV2FieldConfigurationSingleSelect {
                                name
                              }
                              ... on ProjectV2FieldConfigurationText {
                                name
                              }
                            }
                            name
                          }
                          ... on ProjectV2ItemFieldTextValue {
                            field {
                              ... on ProjectV2FieldConfigurationSingleSelect {
                                name
                              }
                              ... on ProjectV2FieldConfigurationText {
                                name
                              }
                            }
                            text
                          }
                        }
                      }
                    }
                  }
                }
              }
            }`;

            let resp;
            try {
              resp = await github.graphql(query, { issueId: issueNodeId });
            } catch (err) {
              core.warning(`GraphQL query failed: ${err}`);
              return;
            }

            const nodes = (((resp || {}).node || {}).projectItems || {}).nodes || [];
            let persona = null;
            let priority = null;

            for (const item of nodes) {
              const fvs = (item.fieldValues && item.fieldValues.nodes) || [];
              for (const fv of fvs) {
                const fieldName = (fv.field && fv.field.name) || (fv.projectField && fv.projectField.name);
                if (!fieldName) continue;
                if (fieldName === 'Persona') {
                  persona = fv.name || fv.text || persona;
                } else if (fieldName === 'Priority') {
                  priority = fv.name || fv.text || priority;
                }
              }
            }

            // Build the desired labels
            const toAdd = [];
            if (persona) {
              const pLabel = `persona:${persona.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9\-]/g,'')}`;
              toAdd.push(pLabel);
            }
            if (priority) {
              const prLabel = `priority:${priority.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9\-]/g,'')}`;
              toAdd.push(prLabel);
            }

            // Current labels on the issue
            const currentLabels = (issue.labels || []).map(l => (typeof l === 'string' ? l : l.name)).filter(Boolean);

            // Compute which labels to remove (other persona:* and priority:* labels not matching desired)
            const toRemove = [];
            for (const cl of currentLabels) {
              if (cl.startsWith('persona:') && !toAdd.includes(cl)) toRemove.push(cl);
              if (cl.startsWith('priority:') && !toAdd.includes(cl)) toRemove.push(cl);
            }

            // Add labels (if any)
            const addUnique = [...new Set(toAdd)];
            if (addUnique.length > 0) {
              try {
                await github.issues.addLabels({ owner, repo, issue_number: issueNumber, labels: addUnique });
                core.info(`Added labels: ${addUnique.join(', ')}`);
              } catch (err) {
                core.warning(`Failed to add labels ${addUnique}: ${err}`);
              }
            }

            // Remove labels no longer applicable
            for (const lbl of toRemove) {
              try {
                await github.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: lbl });
                core.info(`Removed label: ${lbl}`);
              } catch (err) {
                // ignore if label already removed or not present
                core.info(`Could not remove label ${lbl}: ${err.message || err}`);
              }
            }

            core.info(`Sync complete for issue #${issueNumber}. Added: [${addUnique.join(', ')}], Removed: [${toRemove.join(', ')}]`);

            // Optionally fail the job if nothing changed (no-op)
            const failOnNoop = (process.env.FAIL_ON_NOOP || 'false').toLowerCase() === 'true';
            if (addUnique.length === 0 && toRemove.length === 0) {
              if (failOnNoop) {
                core.setFailed(`No persona/priority label updates were applied for issue #${issueNumber}`);
              } else {
                core.info('No persona/priority label changes required (no-op).');
              }
            }
